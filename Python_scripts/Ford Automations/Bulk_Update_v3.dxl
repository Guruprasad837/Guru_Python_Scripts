/***************************DXL SCRIPT TO COPY ATTRIBUTES DEFINITIONS, ATTRIBUTE TYPES AND VIEWS TO MULTIPLE MODULES*******************************************
*
* Purpose     :   This script copies attributes and views from a source module to the target modules specified-
*                 - in the config file "bulk_update_config.ini"     
* Usage       :   The source module or target module location can be an URL or path separated by ("/") either one this script will work 
*                 You need to run this from the source module  
* Author      :   Dr. Stephan Mietens (basis taken from Alexander von Kopp (CC-DA/ESV5) / Asit Ranjan Sahani(RBEI/ESD1))
* Created	  :   01.02.2023
*
* Log of changes
* 	v2, 19-Jan-2024 Le Hong Cong (MS/EET12) Added function to update description of attributes and added checks that all fields in the input file have data
*	v3, 15-Feb-2024 Bridgewater Ana (XC-AS/EPS1.1 NA) Removed checks for attributes and views in input files
*              
* known bug in function:     bool updateDefaultValue(Module srcMod, Module tgtMod, string nameOfAttr)                                                        *
*
* Format of config file is (!!! BEWARE OF SPACES AT THE END OF A LINE, THIS COULD LED TO MISTAKES (E.G. NOT FOUND ATTRIBUTES))
[SOURCE MODULE]
sourcemodule=<full path to module>

[TARGET MODULES]
targetmodule=<full path to module>

[LIST OF ATTRIBUTES TO BE COPIED FROM SOURCE MODULE TO TARGET MODULES]
sourceattribute=<name of attribute>

[LIST OF VIEWS TO BE COPIED FROM SOURCE MODULE TO TARGET MODULES]
sourceview=<name of view>
**************************************************************************************************************************************************************/
pragma runLim, 0

string G_currDir = currentDirectory()
print "working directory: " G_currDir "\n"


// configfile
string G_config_file_path =   G_currDir "//QuickCorrection.ini"


// logfile
string error_log_path = G_currDir"//error.log"
string info_log_path = G_currDir"//info.log"


// -------------------------------------------------------------------

Stream ini = read G_config_file_path
Stream err_log = null, info_log = null
string str_line, srcmodname, tgtmodname, tgt, attr, temp, view_name
Skip target_modules = create
Skip source_attributes = create
Skip source_views = create

Module smod,tmod  // source and target module
AttrDef destAttDef //, attDef	
string attName, typeNm
int i, tgt_ctr = 0, attr_ctr = 0, view_ctr = 0, close_module = 0
bool param_force_copy_if_attribute_missing = false

Regexp re_sourcemodule = regexp2 "^ *sourcemodule *= *(.*)"
Regexp re_targetmodule = regexp2 "^ *targetmodule *= *(.*)"
Regexp re_sourceattribute = regexp2 "^ *sourceattribute *= *(.*)"
Regexp re_sourceview = regexp2 "^ *sourceview *= *(.*)"
Regexp re_url = regexp2 "https" 
Regexp re_forceviewcopy = regexp2 "^forcecopywhenmissingattribute *= *(.*)"

// open log files

if(!canOpenFile(error_log_path,true))
{
	infoBox "cannot create error log!"
	halt
}
if(!canOpenFile(info_log_path,true))
{
	infoBox "cannot create error log!"
	halt
}
err_log = write error_log_path
info_log = write info_log_path

if(null current Module)
{
    close_module = 1
}

void log(string content, string flag){
    if(flag == "INFO"){
        info_log << (stringOf(dateAndTime(today), "yyyy-MM-dd") "INFO" content "\n")
    }else{
        info_log << (stringOf(dateAndTime(today), "yyyy-MM-dd") "ERROR" content "\n")
    }
}

// function to create new attributes in the target modules
bool createAtt(Module tmod, AttrDef ad)
{
    AttrDef destAttDef
    (current ModuleRef__) = tmod
    bool passed = false
    AttrDef__ destAd = attribute ad.name
	print "\n Description................"
	print ad.description
	print "\n............................"
	// if (ad.description != "" && ad.description == "") 
		// destAd = attribute ad.description
	// if (ad.description) destAttDef = modify(destAttDef, setDescription, ad.description)
    if (ad.object) destAd = destAd object
    if (ad.module) destAd = destAd module
    destAd = destAd type ad.typeName
    if (ad.nohistory) destAd = destAd history false
    if (ad.nochanges) destAd = destAd date false
    if (ad.nobars) destAd = destAd changeBars false
    if (ad.multi) destAd = destAd multi true
    if (ad.inherit) destAd = destAd inherit true
    if (ad.hidden) destAd = destAd hidden true
    if (ad.dxl) destAd = destAd dxl ad.dxl
    if (ad.defval) destAd = destAd (default ad.defval)
	// if (ad.description != "" && ad.description == "") 
		// destAd = attribute ad.description
    destAttDef = create destAd
    if (! null(destAttDef))
    {
		AttrDef destAtt = find(tmod,ad.name)
		// if (ad.description != "" && ad.description == "") 
		if(!null(destAtt))
		{	
			modify(destAtt, setDescription, ad.description)
		}
        passed = true
    }
    return passed
}

// updates the value, which is set in attribute, when no explicit value was choosen
bool updateDefaultValue(Module srcMod, Module tgtMod, string nameOfAttr)
{
	// uncheck checkbox for "inherit from parent", if checked
	string returnDef, returnVal
	bool isInheritedDef,isInheritedVal
	AttrDef ad = find(tgtMod, nameOfAttr)
	returnDef = isAccessInheritedDef(tgtMod,ad,isInheritedDef)
	returnVal = isAccessInheritedVal(tgtMod,ad,isInheritedVal)
	int flagWhetherChanged = 0;
	if(isInheritedDef == true)
	{
		errDef = setDef(tgtMod,ad,read|modify|delete,null)
	}
	if(isInheritedVal== true)
	{
		errVal = setVal(tgtMod,ad,read|modify|delete,null)
	}



	//print "Start updateDefaultValue\n"
	AttrDef srcAttDef = find(srcMod, nameOfAttr)
	AttrDef tgtAttDef = find(tgtMod, nameOfAttr)
	if (canModify(tgtMod, nameOfAttr))
	{
		modify(tgtAttDef, setMulti, srcAttDef.multi)
	
		if (srcAttDef.defval) // if  default value for attribute exists:
		{
			//known bug: first run may fail --> current solution: print error, but run frward and run whole script again
			noError()
			modify(tgtAttDef, setDefault, srcAttDef.defval) // update target with source default value
			string ErrMess = lastError()
			if (ErrMess!="")
			{
				print "\n"ErrMess";"
				err_log << "\n"ErrMess";\n"
			}
		}
		else
		{
			//known bug: first run may fail --> current solution: print error, but run frward and run whole script again
			noError()
			modify(tgtAttDef, setDefault, "") // remove default value
			string ErrMess2 = lastError()
			if (ErrMess2!="")
			{
				print "\n"ErrMess2";"
				err_log << "\n"ErrMess2";\n"
			}
			//if (ErrMess!="")
			//{
			//	noError()
			//	modify(tgtAttDef, setDefault, "") // remove default value
			//	string ErrMess = lastError()
			//	print ";"ErrMess";"
			//}
		}
		return true
	}
	return false
}


// function to create missing attribute types in the target modules
bool createType(Module smod, Module tmod, string nameOfType)
{				

	// check, if target module exists:
	if(null tmod)	return false

	// check, if source module exists:
	if(null smod) return false;
				
	// check, if attribute type exists:
	AttrType attTypeTarget = find(tmod, nameOfType)
	if (!null attTypeTarget)return false;
				
	
	(current ModuleRef__) = tmod
    bool boundSet, passed = false
    string errMsg = null
    AttrType targetAttTypeBeforeUpdate
    AttrType attType = find(smod, nameOfType)
	if (null attType) {
		print "Attribute '" nameOfType "' not found in '" smod."Name" "'\n";
		err_log << "\nAttribute '" nameOfType "' not found in '" smod."Name" "'\n"
		return false;
	}
    string baseType = attType.type ""
    
    if (baseType == "Real") 
    {
        targetAttTypeBeforeUpdate = create(attType.name, attrReal, errMsg)
        boundSet = attType.minValue
        if (boundSet)
        {
            real minVal = attType.minValue
            setMinValue(targetAttTypeBeforeUpdate, minVal, true)
        }
        boundSet = attType.maxValue
        if (boundSet)
        {
            real maxVal = attType.maxValue
            setMaxValue(targetAttTypeBeforeUpdate, maxVal, true)
        }
    }
    else if (baseType == "Integer")
    {
        targetAttTypeBeforeUpdate = create(attType.name, attrInteger, errMsg)
        boundSet = attType.minValue
        if (boundSet) 
        {
            int minVal = attType.minValue
            setMinValue(targetAttTypeBeforeUpdate, minVal, true)
        }
        boundSet = attType.maxValue
        if (boundSet)
        {
            int maxVal = attType.maxValue
            setMaxValue(targetAttTypeBeforeUpdate, maxVal, true)
        }
    }
    else if (baseType == "Date")
    {
        targetAttTypeBeforeUpdate = create(attType.name, attrDate, errMsg)
        boundSet = attType.minValue
        if (boundSet)
        {
            Date minVal = attType.minValue
            setMinValue(targetAttTypeBeforeUpdate, minVal, true)
        }
        boundSet = attType.maxValue
        if (boundSet)
        {
            Date maxVal = attType.maxValue
            setMaxValue(targetAttTypeBeforeUpdate, maxVal, true)
        }
    }
    else if (baseType == "String") 
    {
        create(attType.name, attrString, errMsg)
    }
    else if (baseType == "Text") 
    {
        create(attType.name, attrText, errMsg)
    }
    else if (baseType == "Enumeration") 
    {
        setRealColorOptionForTypes(true)
        string options[attType.size]
        int vals[attType.size]
        int cols[attType.size]
        bool keepVals = false
        for (i = 0; i < attType.size; i++) 
        {
            options[i] = attType.strings[i]
            cols[i] = attType.colors[i]
            vals[i] = attType.values[i]
            if (i != attType.size)
            {
                keepVals = true
            }
        }   
		(current ModuleRef__) = tmod		
        if (keepVals)
        { 
            create(attType.name, options,  vals, cols, errMsg)  
			print errMsg
			err_log << "\n"errMsg";\n"
        }
        else
        {
			
            create(attType.name, options, errMsg)
        }
    }
    else
    {
        infoBox "Unable to create type '" attType.name "' due to unknown base type '" baseType "' in '" tmod."Name" "' !"
		err_log << "\nUnable to create type '" attType.name "' due to unknown base type '" baseType "' in '" tmod."Name" "' !\n"
    }
    if (null errMsg) 
    {
        passed = true
    }
    else 
    {
        infoBox "Unable to create type:\n" errMsg
		// err_log << "Unable to create type:" errMsg "\n"
    }
    return passed 
}



//



    
// extend ONLY EXISTING attribute type definitions! (maps only existing attribute type values with same name)
// elements of target, which doesn't exist in source, will be shifted to the end of the type definition
bool extendAttrTypeFromSrc(Module srcMod, Module tmod, string nameOfType)
{
	//print "Start extendAttrTypeFromSrc\n"
	string tmodName = tmod."Name"

    string attName
    AttrType srcAttType = find(srcMod, nameOfType)
    AttrType targetAttType=find (tmod,nameOfType)
    attName=nameOfType
    //attDef=find(srcMod,attName)
    //destAttDef=find(tmod,attName)
    bool passed=false

    if (null(srcAttType))
    {
        infoBox " Attribute '" attName "' does not exist in Source Module '" srcMod."Name" "'!;"
		err_log << "\nAttribute '" attName "' does not exist in Source Module '" srcMod."Name" "'!;\n"
		return false // need source to copy!
    }
    if(null(targetAttType))
    {
        infoBox " Attribute '" attName "' Does not exist in  Target Module '" tmod."Name" "'!;"
		err_log << "\nAttribute '" attName "' Does not exist in  Target Module '" tmod."Name" "'!;\n"
		return false // function only for previously defined attribute types
    }
    

	string baseTypeSrc = srcAttType.type ""
	string baseTypetgt = targetAttType.type ""
	
	
	if(baseTypeSrc == baseTypetgt)
	{
		if(baseTypeSrc == "Enumeration" )   // Check for the input attribute type
		{
			// algorithm: 
			// - count number of unique values in both type definitions
			// - copy all source elements to new list and map position to old position in type definition, if element exists in target
			// - copy all old values, which are not a new value at the same time, behind the other elements and map them
			// - modify attribute type definition
			
			
			// create a list with all elements of source to easy find duplicates in source and target fwith function "find()"
			Skip typeListSrc = createString()
			int i
			// put all elements of source into list
			for (i = 0; i < srcAttType.size; i++) 
			{
				put(typeListSrc, srcAttType.strings[i], srcAttType.strings[i])
			}
			
			// check if elemeten exist in both attribute type definitions
			int sizeSrcTgt = srcAttType.size // number of all elements (no duplicates) of source and target; starts with number of elements of source, because they are unique
			bool dataExistInSrcAndTgt = false;
			for (i = 0 ; i < targetAttType.size; i++) 
			{
				dataExistInSrcAndTgt = find(typeListSrc, targetAttType.strings[i])
				if (!dataExistInSrcAndTgt)  // count, if element is new and doesn't exist in source
				{
					sizeSrcTgt++
				}
			}

			// create new type defintion with values of both type definitions. first all source elements, then all unique others
			int arrMaps[sizeSrcTgt] // maps old values to new ones
			string new_strings[sizeSrcTgt]
			int new_values[sizeSrcTgt]
			int new_colors[sizeSrcTgt]
			// copy all elements of source into array;
			i = 0 
			for (i = 0; i < srcAttType.size; i++) 
			{	
				arrMaps[i] = -1  //-1 means new value for type definition
				new_strings[i] = srcAttType.strings[i]
				new_values[i] = srcAttType.values[i]
				new_colors[i] = srcAttType.colors[i]
				int k
				for (k = 0; k<targetAttType.size; k++) 
				{
					if (targetAttType.strings[k] == new_strings[i])
					{
						arrMaps[i] = k // maps elements of source to element of 
					}
				}
			}
			
			// add elements of target, which shall not be deleted
			int counter_add = 0;
			for (j = 0; j < targetAttType.size; j++)
			{
				dataExistInSrcAndTgt = find(typeListSrc, targetAttType.strings[j])
				if (!dataExistInSrcAndTgt)  // count, if element is new and doesn't exist in source
				{
					
					//print "i:" i " j:" j" counter:" counter_add " \n"
					arrMaps[srcAttType.size+counter_add] = j  //-1 means new value for type definition
					new_strings[srcAttType.size+counter_add] = targetAttType.strings[j]
					new_values[srcAttType.size+counter_add] = targetAttType.values[j]
					new_colors[srcAttType.size+counter_add] = targetAttType.colors[j]
					counter_add++
				}
			}
			
			// change value for default colors, maybe bug with color number 62 ...
			for (i = 0; i < sizeSrcTgt; i++) 
			{
				if (new_colors[i] == 62){
					new_colors[i] = -1
				}
				// print values for debugging:
				// print "arrMaps:"arrMaps[i] "\tstring:" new_strings[i] " \tcolors:" new_colors[i] "   \tvalues:" new_values[i] " \n"
			}
		
			delete(typeListSrc) // delete, because no garbage collection
			
			string errmsg = ""
			AttrType targetAttTypeAfterUpdate  = modify(targetAttType, srcAttType.name , new_strings, new_values, new_colors, arrMaps, errmsg)
			
			if(errmsg == "")    // Check for any error in copy
			{ 
				passed = true
				print ";attribute definition of '" attName"' in target module '" tmod."Name" "' was updated from source '" srcMod."Name" ";"
				info_log << "\nAttribute definition of '" attName"' in target module '" tmod."Name" "' was updated from source '" srcMod."Name" ";\n"
			}
			else
				print ";ERROR in copy : " errmsg ";"
				err_log << "\nERROR in copy : " errmsg " for '" attName"' in target module '" name(tmod) "\n"
		}
		 // in case if input attribute type is not enumeration
		else
		{
			print " Standard Type " baseTypeSrc " can not be extended;"
			err_log << "\nStandard Type " baseTypeSrc " can not be extended for '" attName"' in target module '" name(tmod)";\n"
		}
	}
	else
	{
		print "Basetypes are different: '" baseTypeSrc "'(Source) != '" baseTypetgt "'(Target);"
		err_log << "\nBasetypes are different: '" baseTypeSrc "'(Source) != '" baseTypetgt "'(Target);\n"
		return false
	}
		
    return passed 
}


//###############################################################################################################################
//####################              COPY VIEWS                     ##############################################################
//###############################################################################################################################


// Clears the destination view.
void clearDest(Module m)
{
    Column c
    int i, count
    count = 0
    c = column(m, 0)
    if (!null c)
    { 
        for c in m do
        {
            count++
        }
    }
    else{}  // DXL Bug: the for c in m do loop aborts if there are no columns.
    (current ModuleRef__) = m
    for (i = 0; i < count; i++)
    {
        delete(column(0))
    }
    filtering(off)
    sorting(off)
    outlining(off)
    level(0)
}


// Copies views from the list to the passed module.
void copyViews(Module toMod,Module smod,string view_name)
{
    Column srcCol, destCol
    int viewPos, vLevel
    ViewDef vDef
    Filter vFilt
    Sort vSort
    bool vOutline, err
    string errMsg
    string NameMod = name(toMod)
    string src_view_names,tgt_view_names
    int flag_view_exists_insrc=0,flag_view_exists_intgt=0
    
    if (null toMod)
        return
    
	print "\n processing view" view_name "\n"
	
    for src_view_names in views(smod) do
    { 
        if(src_view_names == view_name)
            flag_view_exists_insrc=1   // Set flag if View is present in the source module
    } 
    
    for tgt_view_names in views(toMod) do
    { 
        if(tgt_view_names == view_name)
            flag_view_exists_intgt=1  //Set flag if View is present in the Target module
    } 
    
    if(flag_view_exists_insrc==1)
    {
        if(flag_view_exists_intgt==1)
        {
            print ";View '" view_name "' is already present in target module '" name(toMod) "';"
			info_log << "\nView '" view_name "' is already present in target module '" name(toMod) "';\n"
            print "Updating View"
        }
        
        viewName = view_name              
        err = false
        vFilt = null
        vSort = null
        
        clearDest(toMod)
        
        (current ModuleRef__) = smod
        // deletions(true)
		// refresh(smod)
		// synchExplorer smod
        if (load(smod,view(viewName)))
        {
            vDef = get(view(viewName))
            (current ModuleRef__) = toMod
			
            int colCount = 0
			Column col
			int index=0
            
            for srcCol in smod do
            {
				int flag_discussion_col=0
				destCol = column colCount++
                string colTitle = title(srcCol)
				print "View column: " colTitle "\n"
                
                if(isDiscussionColumn(srcCol))
				{
					flag_discussion_col=1  //Set flag if the column is of Discussion type
					print " is discussion type \n"
				}
                string attNameView = attrName(srcCol)
                if (null(attNameView))  // is it an attribute?
                {
                    if (main(srcCol))  // is it the main column?
                    {
                        main(destCol)
                    }
                    else // it's not the main column
                    {
						if(flag_discussion_col ==1) // is it discussion column?
						{
							string s=dxlFilename(srcCol)
							dxl(destCol, dxl(srcCol))
							setDiscussionColumn(destCol, s)
							width(destCol, 100)
							refresh(toMod, false)
						}
						else // must be layoutDXL column then
						{
							dxl(destCol, dxl(srcCol))
						}

						// in both cases discussion or layoutDXL column, copy refresh behaviour
						setManualRefresh(destCol, isManualRefresh(srcCol))
						setRefreshDelta(destCol, getRefreshDelta(srcCol))					
                    }
                }
                else // it's an attribute
                {
                    AttrDef ad = find(toMod, attNameView)
					// check if view can't be copied as attributes are missing in target module
                    if ((null(ad)) and attNameView != "Object Identifier" and attNameView != "Object Number" and attNameView != "Object Level" and attNameView != "Object Type")
                    {
                        print ";"name(toMod) " lacks attribute '" attNameView "' \tfor this view '" viewName "'.;"
						err_log << "\n"name(toMod) " lacks attribute '" attNameView "' \tfor this view '" viewName "'.;\n"
                        err = true
                        //Don't stop, find all errors 
                    } 
                    else // attribut available in target module, copy can be done
                    {
//						if(flag_discussion_col ==1) // this seems stupid, an attribute is no discussion (why ever this seems sometimes was identified as such)
//						{
//							string s=dxlFilename(srcCol)
//							print "process " colTitle " in  module " s "\n"
//							dxl(destCol, dxl(srcCol))
//							setDiscussionColumn(destCol, s)
//							width(destCol, 100)
//							refresh(toMod, false)
//						}
//						else
//                        {
                            attribute(destCol, attNameView)
							// text color in view for column
                            string color_att=color(srcCol)
                            if(color_att != "")
                                color(destCol,color_att)
							// background color in view for column
							string bgcolor_att=backgroundColor(srcCol)
                            if(bgcolor_att != "")
                                backgroundColor(destCol,bgcolor_att)
//                        }
                    }
                }
                if (! main(srcCol)) 
                {
                    title(destCol, colTitle)
                }
                
                int colWidth = width(srcCol)
                width(destCol, colWidth)
                justify(destCol, justify(srcCol))
                if (!null color(srcCol))
                {
                    color(destCol, color(srcCol))         //to copy colours as well
                }
            }   // end for columns currently displayed in the source module
            
            if (err)
            {
                print "View copied with missing attributes."
				err_log << "\nView copied with missing attributes in -> "name(toMod)"\n"
            }
            // Now save the view in the target module.
            (current ModuleRef__) = smod
            if (filtering(smod))
            {
                vFilt = current
            }
            if (sorting(smod))
            {
                vSort = current
            }
            vLevel = level(smod)
            vOutline = outlining(smod)
            (current ModuleRef__) = toMod
            noError
            if (! null vFilt)
            {
                set(toMod, vFilt)
                filtering(on)
            }
            errMsg = lastError
            if (! null(errMsg))
            {
                // Note: all system errors already end with an EOL ";":
                print ";"name(toMod) "\tUnable to copy view '" viewName ",' due to " errMsg
				err_log << "\n"name(toMod) "\tUnable to copy view '" viewName ",' due to " errMsg"\n"
                
            }
            noError
            if (! null vSort)
            {
                set(toMod, vSort)
                sorting(on)
            }
            errMsg = lastError
            if (! null(errMsg))
            {
                print ";"name(toMod) "Unable to copy view '" viewName ",' due to " errMsg
                err_log << "\n"name(toMod) "Unable to copy view '" viewName ",' due to " errMsg"\n"
            }
            level(vLevel)
            outlining(vOutline)
            noError()
            save(toMod,view(viewName),vDef)
			// deletions(true)
			// refresh(toMod)
			// synchExplorer toMod
            string ErrMess = lastError()
            if (!null ErrMess)
            { 
                print ";'" NameMod "': Error saving view '" viewName "'" ErrMess
				err_log << "\n'" NameMod "': Error saving view '" viewName "'" ErrMess "\n"
            }
            else
            { 
                string modView = getDefaultViewForModule(smod)
                if (! null modView)
                {
                    setDefaultViewForModule(toMod, modView)
                }
                print ";View '" viewName "' successfully copied to module '" name(toMod) "'"
				info_log << "\nView '" viewName "' successfully copied to module '" name(toMod) "'\n"
            }
        }
        else
        {
            print ";Unable to load view '" viewName "' at the source;"
			err_log << "\nUnable to load view '" viewName "' at the source "name(smod)"\n"
        }
    }
    else 
	{
        print ";View '" view_name "' is not present in the source module '" name(smod) "'"
		err_log << "\nView '" view_name "' is not present in the source module '" name(smod) "'\n"
	}
    // refresh modBL1
	// synchExplorer modBL1
}
// copyViews

//###############################################################################################################################
//###############################################################################################################################
//###############################################################################################################################

//extracting attributes, views and target module names from the config file
bool debug = false;
void printlndebug(string msg)
{
    if(debug){
        print(msg "\n");
    }
}

string getFullPath(Folder f)
{
    if (f == null)
    {
        printlndebug("getFullPath2 : f is null");
        return "";
    }
    else if(name(f) == "Root Folder")
    {
        return "";
    }
    else{
        printlndebug("getFullPath : " name(f));
        Folder fParent = getParentFolder(f);
        if(fParent == null)
        {
            return name(f); 
        }
        else
        {
            return getFullPath(fParent) "/" name(f);
        }
    }
}
string getDatabaseLocation(string location)
{
    string ret = "";
    Item i = item(location);
    string iFullName = fullName(i);
    Folder p = getParentFolder(i);
    string fullPath = getFullPath(p);
    string result = fullPath "/" name(i);
    return result;
}

// Convert url to DOORs path
string resolve(string url)
{
    string result = null;
    ModuleVersion mv;
    Item i;
    string dbHost = null;
    string protocol = null;
    string repositoryId = null;
    int dbPort;
    string dbName;
    string dbID = null;
    string viewName = null;
    int objectAbsno = -1;
    result = decodeResourceURL(url, protocol, dbHost, dbPort, repositoryId, dbName, dbID, i, mv, viewName, objectAbsno);
    if (null result) 
    { 
        if (null i) 
        { 
            errorBox ("Resolved Item is null");
        } 
        else if (null mv) 
        { 
            string sType = type i;
            
            if(sType=="Project" or sType=="Folder"){
                return (fullName i);
                //return (getDatabaseLocation((fullName i)));
            }else{
                errorBox ("ModuleVersion is null, Item : " (type i) ": " (fullName i) ": " (description i));
            }
        } 
        else 
        {    
            return (fullName mv);
            //return (getDatabaseLocation((fullName i)));
        } 
    } 
    else
    {
        errorBox (result);
    }
}

//###############################################################################################################################
//###############################################################################################################################
//###############################################################################################################################

// print all possible values of a attribute type in a given module:
void printAttributeDefinition(Module mod, string attName)
{
	// check existence of attribute:
	AttrType attType = find(mod, typeNm)
	if (null(attType))
	{
		print "attribute type '" attName "' does not exist in module '" name(mod) "'  ;  "
		err_log << "\nAttribute type '" attName "' does not exist in module '" name(mod) "'  ;  \n"
		return
	}
	
	Module tmp = current; // save current module
	(current ModuleRef__) = mod;
	
	// print base type:
	string baseType = attType.type ""
	print baseType "  ;  "
	
	// print possible values fpr enumaration:
	if(baseType == "Enumeration")
	{
		for (i = 0; i < attType.size; i++) 
		{
			print attType.strings[i] "  ;  "
			print attType.values[i] "  ;  " 
		}
	}
	
	(current ModuleRef__) = tmp; //restore 
}


//###############################################################################################################################
//###############################################################################################################################
//###############################################################################################################################
//	START OF SCRIPT
//###############################################################################################################################
//###############################################################################################################################
//###############################################################################################################################


// if(close_module == 1)
// {
	
// 	close(smod)
// 	smod = read(srcmodname, false,true)
// 	(current ModuleRef__) = smod
// 	deletions(true)
// 	refresh(smod)
// 	synchExplorer smod
// 	// save(smod)
// 	// close(tmod)
// }

// for tgt in target_modules do 
// {
	
// 	tmod = read(tgt, false , true)
// 	(current ModuleRef__) = tmod
// 	deletions(true)
// 	refresh(tmod)
// 	synchExplorer tmod
// 	// save(tmod)
// 	// close(tmod)
	
// }



bool check_list_empty(Skip skp){
    string ktemp 
    int count = 0
    for ktemp in skp do {
        count++
    }
    return count == 0 ? true: false

}

void getListInput(Skip target_modules,source_attributes, source_views, string& source_module_path){

    log("Reading config file","INFO")

     // try-catch error when read config file
    noError()	
	ini = read G_config_file_path
	err_msg = lastError()


    if(!null err_msg){
        log("Error in reading config file:   " G_config_file_path, "ERROR")
        infoBox "Error in reading config file : " G_config_file_path
        halt 
       
    }else{
        while (true) 
        {
            //reads one line at a time 
            ini >> str_line  
   
            if(re_sourcemodule str_line)
            {   
                srcmodname = str_line[match 1]
                source_module_path = srcmodname
            }
            
            if(re_targetmodule str_line)
            {
                string trgtmodname = str_line[match 1]
                if(re_url trgtmodname)
                {
                trgtmodname = resolve(trgtmodname)
                //print "This is Target URL \n"
                }
                //print trgtmodname "\n"
                if(trgtmodname != "")
                {
                    tgt_ctr++
                    put(target_modules, tgt_ctr, trgtmodname)
                }
            }
            
            if(re_sourceattribute str_line)
            {
                if(str_line[match 1] != "")
                {
                    attr_ctr++
                    put(source_attributes, attr_ctr, str_line[match 1])
                }   
            }
            
            if(re_sourceview str_line)
            {
                if(str_line[match 1] != "")
                {
                    view_ctr++
                    put(source_views, view_ctr, str_line[match 1])
                }   
            }

            if(re_forceviewcopy str_line)
            {   
                param_force_copy_if_attribute_missing = (intOf(str_line[match 1]) == 1)
            }
            
            if (end of ini)
            {
                break
            }
        
        }

    }

    close ini
    
}

void updateTarget(Module smod, Skip target_modules,source_attributes, source_views ){
    string errMsg = null
    string tgt 
    Module tmod
    for tgt in target_modules do
    {	
        
        (current ModuleRef__) = smod
        
        tgtmodname = tgt
        
        tmod = edit(tgtmodname, true , true)
        
        if(null tmod)
        {
            //infoBox "Cannot open module '" tgtmodname "'!"
            print "\nCannot open module! Module '" tgtmodname "' is locked at " dateAndTime(today) ""
            err_log << "\nCannot open module! Module '" tgtmodname "' is locked at " dateAndTime(today) "\n"
            continue
        }
        //to copy attributes    
        for attr in source_attributes do
        {
            print "\n" name(tmod) ";" // print modul name to filter 
            info_log << "\n" name(tmod) ";\n" // print modul name to filter 
            err_log << "\n" name(tmod) ";\n" // print modul name to filter 
            attName = attr   
            print "Test existence of '" attName "' in module '" name(tmod) "'.  ;  "
            // info_log << "\nTest existence of '" attName "' in module '" name(tmod) "'.  ;  \n"
            
            AttrDef attDef
            attDef = find(smod, attName)                // retrieve the attribute from the source module
            if (null(attDef))
            {
                print "Error, Attribute "attName " not found\n"
                err_log << "\nError: Attribute " attName " not found  in source\n"
                //continue    
            }
            typeNm = attDef.typeName		// try to locate the same attribute in the target module
            destAttDef = find(tmod, attName) 
            if (null(destAttDef)) 	// attribute still not exist --> create
            {   
                print "Attribute '" attName "' does not exist in module '" name(tmod) "'.  ;  Check if type '" typeNm "' of Attribute '" attName "' exists in module.  ;  "
                err_log << "\nAttribute '" attName "' does not exist in module '" name(tmod) "'.  ;  Check if type '" typeNm "' of Attribute '" attName "' exists in module.  ;  \n" 
                
                AttrType attType = find(tmod, typeNm)   // check if the type exists in target module
                //print attType.name
                //print stringOf attType.type
                //print (!null(attType)) ""
                if (null(attType)) // type of Attribute does not exist in target module
                {   
                    print "Type '" typeNm "' does not exist in module '" name(tmod) "'.  ;  "
                    err_log << "\nType '" typeNm "' does not exist in module '" name(tmod) "'.  ;  \n"
                    if(!createType(smod, tmod, typeNm))
                    {
                        print "Unable to create attribute type '" typeNm "' in module '" name(tmod) "' !  ;  "
                        err_log << "\nUnable to create attribute type '" typeNm "' in module '" name(tmod) "' !  ;  \n"
                        continue
                    }
                    else
                    {
                        print "Attribute type '" typeNm "' copied from module '" name(smod) "' to module '" name(tmod) "' !  ;  "
                        info_log << "\nAttribute type '" typeNm "' copied from module '" name(smod) "' to module '" name(tmod) "' !  ;  \n"
                    }   
                }
                else
                {
                    print "Type '" typeNm "' exists in module '" name(tmod) "'. Update Type. ;"
                    info_log << "\nType '" typeNm "' exists in module '" name(tmod) "'. Update Type. ;\n"
                    flag_copy_status = extendAttrTypeFromSrc(smod, tmod, typeNm)
                    if (flag_copy_status)
                    {
                            print "Type '" typeNm "' was updated.;"
                            info_log << "\nType '" typeNm "' was updated in '" name(tmod) "'\n"
                    } else
                    {
                            print "Unable to update Type '" typeNm "'.;"
                            err_log << "\nUnable to update Type '" typeNm "' in '" name(tmod) "'\n"
                    }
                }
                
                attType = find(tmod, typeNm)   // check again, if the type now exists in target module (2 cases: type existed before OR type was created now)
                if (!null(attType)) //  type exists in target module (the exact possible values of the type are not important/checked!
                {
                    if(createAtt(tmod,attDef))
                    {
                        print "Copied '" attName "' from '" name(smod) "' to '" name(tmod) "'.  ;  "
                        info_log << "\nCopied '" attName "' from '" name(smod) "' to '" name(tmod) "'.  ;  \n"
                    }
                    (current ModuleRef__) = smod
                }
            }
            else // update existing type definition; if type definition not exists--> no update of type
            {
                        
                
                print "Attribute '" attName "' already exists in '"  name(tmod) "'. Update Type definition, if definition exists ;;;; "
                info_log << "\nAttribute '" attName "' already exists in '"  name(tmod) "'. Update Type definition, if definition exists\n" 
                
                AttrDef adTarget = find(tmod,attName)
            
                if(!null(adTarget))
                {	
                    print "\nsourceDesc: " attDef.description "\n"
                    print "TargetDesc: " adTarget.description "\n"
                    print "modify?" canModify(tmod,attName)"" "\n"
                    string tmpDesc = attDef.description
                    modify(adTarget, setDescription, tmpDesc)
                    if(!null(attDef.dxl))
                    {
                        modify(adTarget, setDXL, attDef.dxl)
                    }
                }
                
                flag_copy_status = extendAttrTypeFromSrc(smod, tmod, typeNm)
                updateDefaultValue(smod, tmod, attName)

                
            }
            // print attribute type definition from source and target module to the command line to compare manually:
            print "Please check, if the existing type have all necessary possible values. ;  "
            print "Source attribute type:  ;  "
            printAttributeDefinition(smod, typeNm);
            print "Target attribute type:  ;  "
            printAttributeDefinition(tmod, typeNm);
        }
        
        //to copy views 
        //copyViews(tmod, smod, source_views) 
        string viewToCopy
        for viewToCopy in source_views do
        {
            copyViews(tmod,smod,viewToCopy)
        }
        
        save(tmod)
        // (current ModuleRef__) = tmod
        
        // deletions(true)
        // refresh(tmod)
        // synchExplorer tmod
        close(tmod)
    }

}

void fixModule(){
    Module sourceModule, targetModule
    string source_module_path = null
    Skip target_modules, source_attributes, source_views
    target_modules = create
    source_attributes = create
    source_views = create
   

    getListInput(target_modules,source_attributes, source_views, source_module_path)


    if(null source_module_path){
        log("Source module path is null", "ERROR")
        errorBox "Source module path is null"
        halt
    }
     // check empty List module path and List type name
    if(check_list_empty( target_modules)) {
        log("List Target Module is emtpy", "ERROR")
        errorBox "List Module is empty  "
        halt
    }
    // if(check_list_empty( source_attributes)) {
        // log("List attribute is emtpy", "ERROR")
        // errorBox "List attribute is empty"
        // halt
    // }
    // if(check_list_empty( source_views)) {
        // log("List views is emtpy", "ERROR")
        // errorBox "List views is emtpy"
        // halt
    // }


    sourceModule = read(source_module_path,false)

    if(null sourceModule){
        log("Can not open source module:  " source_module_path, "ERROR" )
        errorBox "Cannot open source module"
        halt
    }


    updateTarget(sourceModule, target_modules,source_attributes, source_views )
    

    delete(target_modules) // delete, because no garbage collection
    delete(source_attributes)  // delete, because no garbage collection
    delete(source_views)  // delete, because no garbage collection

    
}


void main(){
    fixModule()
}
print "Start"
main()
print "Ready"

delete(re_sourcemodule)
delete(re_targetmodule)
delete(re_sourceattribute)
delete(re_sourceview)
delete(re_url)
delete(re_forceviewcopy)
